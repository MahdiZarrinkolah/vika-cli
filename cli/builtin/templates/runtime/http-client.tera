import type { ApiResult } from "./types";

/**
 * Configuration options for VikaClient.
 * 
 * @example
 * ```typescript
 * const client = new VikaClient({
 *   baseUrl: "https://api.example.com",
 *   timeout: 5000,
 *   retries: 3,
 *   retryDelay: 1000,
 *   headers: { "X-Custom-Header": "value" },
 *   auth: "bearerToken"
 * });
 * ```
 */
export interface VikaClientOptions {
  /** Base URL for all requests. Can be overridden per-request with full URLs. */
  baseUrl?: string;
  /** Request timeout in milliseconds. Default: 10000 */
  timeout?: number;
  /** Number of retry attempts for failed requests. Default: 0 */
  retries?: number;
  /** Delay between retries in milliseconds (exponential backoff). Default: 250 */
  retryDelay?: number;
  /** Default headers to include in all requests. */
  headers?: Record<string, string>;
  /** Authentication strategy. Use middleware to implement actual auth logic. */
  auth?: "bearerToken" | "fixed" | "consumerInjected";
}

/**
 * Request context passed to beforeRequest middleware.
 * You can modify headers, body, etc. before the request is sent.
 * 
 * @example
 * ```typescript
 * client.useBeforeRequest(async (ctx) => {
 *   ctx.headers["Authorization"] = `Bearer ${getToken()}`;
 * });
 * ```
 */
export interface RequestContext {
  /** HTTP method (GET, POST, etc.) */
  method: string;
  /** Full request URL */
  url: string;
  /** Request headers (modifiable) */
  headers: Record<string, string>;
  /** Request body (modifiable) */
  body?: any;
  /** Raw request options passed to request() */
  rawOptions?: any;
}

/**
 * Response context passed to afterResponse middleware.
 * Contains the request context, fetch Response, and parsed data.
 * 
 * @example
 * ```typescript
 * client.useAfterResponse(async (ctx) => {
 *   console.log(`Request to ${ctx.request.url} returned ${ctx.response.status}`);
 * });
 * ```
 */
export interface ResponseContext {
  /** Original request context */
  request: RequestContext;
  /** Fetch Response object */
  response: Response;
  /** Parsed response data (JSON or text) */
  data: any;
}

/**
 * Middleware function called before each request.
 * Use this to modify headers, add auth tokens, log requests, etc.
 */
export type BeforeRequestMiddleware = (ctx: RequestContext) => Promise<void> | void;

/**
 * Middleware function called after each successful response.
 * Use this to log responses, transform data, etc.
 */
export type AfterResponseMiddleware = (ctx: ResponseContext) => Promise<void> | void;

/**
 * Middleware function called when a request fails (after retries exhausted).
 * Use this for error logging, notifications, etc.
 */
export type ErrorMiddleware = (error: any, ctx: RequestContext) => Promise<void> | void;

/**
 * Options for individual requests.
 * 
 * @example
 * ```typescript
 * const result = await client.get("/users", {
 *   headers: { "X-Custom": "value" },
 *   signal: abortController.signal
 * });
 * ```
 */
export interface RequestOptions {
  /** Additional headers for this request (merged with default headers) */
  headers?: Record<string, string>;
  /** Request body (automatically JSON.stringify'd if object) */
  body?: any;
  /** AbortSignal for request cancellation */
  signal?: AbortSignal;
  /** Additional options (for extensibility) */
  [key: string]: any;
}

/**
 * HTTP client for making typed API requests with middleware support.
 * 
 * @example
 * ```typescript
 * import { vikaClient } from "./runtime";
 * 
 * // Configure default instance
 * vikaClient.useBeforeRequest(async (ctx) => {
 *   ctx.headers["Authorization"] = `Bearer ${getToken()}`;
 * });
 * 
 * // Or create custom instance
 * const customClient = new VikaClient({
 *   baseUrl: "https://api.example.com",
 *   timeout: 5000
 * });
 * ```
 */
export class VikaClient {
  private baseUrl: string;
  private timeout: number;
  private retries: number;
  private retryDelay: number;
  private headers: Record<string, string>;
  private auth: "bearerToken" | "fixed" | "consumerInjected" | undefined;
  private beforeRequest: BeforeRequestMiddleware[];
  private afterResponse: AfterResponseMiddleware[];
  private onError: ErrorMiddleware[];

  /**
   * Create a new VikaClient instance.
   * 
   * @param options - Configuration options
   */
  constructor(options: VikaClientOptions = {}) {
    this.baseUrl = options.baseUrl ?? "";
    this.timeout = options.timeout ?? 10000;
    this.retries = options.retries ?? 0;
    this.retryDelay = options.retryDelay ?? 250;
    this.headers = options.headers ?? {};
    this.auth = options.auth;
    this.beforeRequest = [];
    this.afterResponse = [];
    this.onError = [];
  }

  /**
   * Register middleware to run before each request.
   * Useful for adding auth tokens, logging, etc.
   * 
   * @example
   * ```typescript
   * client.useBeforeRequest(async (ctx) => {
   *   const token = await getAuthToken();
   *   ctx.headers["Authorization"] = `Bearer ${token}`;
   * });
   * ```
   */
  useBeforeRequest(fn: BeforeRequestMiddleware): void {
    this.beforeRequest.push(fn);
  }

  /**
   * Register middleware to run after each successful response.
   * Useful for logging, data transformation, etc.
   * 
   * @example
   * ```typescript
   * client.useAfterResponse(async (ctx) => {
   *   console.log(`Request succeeded: ${ctx.request.url}`);
   * });
   * ```
   */
  useAfterResponse(fn: AfterResponseMiddleware): void {
    this.afterResponse.push(fn);
  }

  /**
   * Register middleware to run when requests fail (after retries exhausted).
   * Useful for error logging, notifications, etc.
   * 
   * @example
   * ```typescript
   * client.useError(async (error, ctx) => {
   *   console.error(`Request failed: ${ctx.url}`, error);
   *   await sendErrorNotification(error);
   * });
   * ```
   */
  useError(fn: ErrorMiddleware): void {
    this.onError.push(fn);
  }

  async request<
    SuccessMap extends Record<number, any>,
    ErrorMap extends Record<number, any>
  >(
    method: string,
    path: string,
    opts: RequestOptions = {}
  ): Promise<ApiResult<SuccessMap, ErrorMap>> {
    const url = path.startsWith("http") ? path : `${this.baseUrl}${path}`;
    
    // Prepare request context
    const requestContext: RequestContext = {
      method,
      url,
      headers: { ...this.headers, ...opts.headers },
      body: opts.body,
      rawOptions: opts,
    };

    // Run beforeRequest middlewares
    for (const middleware of this.beforeRequest) {
      await middleware(requestContext);
    }

    // Note: Auth strategies are hints for middleware implementation.
    // For "bearerToken": Use middleware to inject token dynamically
    // For "fixed": Set headers in constructor options
    // For "consumerInjected": Consumer handles all auth via middleware

    // Prepare fetch options
    const fetchOptions: RequestInit = {
      method,
      headers: requestContext.headers,
      ...(opts.signal && { signal: opts.signal }),
    };

    if (opts.body !== undefined) {
      if (typeof opts.body === "string") {
        fetchOptions.body = opts.body;
      } else {
        fetchOptions.body = JSON.stringify(opts.body);
        if (!requestContext.headers["Content-Type"]) {
          requestContext.headers["Content-Type"] = "application/json";
        }
      }
    }

    // Retry logic
    let lastError: any;
    for (let attempt = 0; attempt <= this.retries; attempt++) {
      try {
        // Create abort controller for timeout
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), this.timeout);
        
        // Merge abort signal
        if (opts.signal) {
          opts.signal.addEventListener("abort", () => controller.abort());
        }

        const signal = controller.signal;
        fetchOptions.signal = signal;

        const response = await fetch(requestContext.url, fetchOptions);
        clearTimeout(timer);

        // Parse response
        let data: any;
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("application/json")) {
          try {
            data = await response.json();
          } catch {
            data = await response.text();
          }
        } else {
          data = await response.text();
        }

        // Prepare response context
        const responseContext: ResponseContext = {
          request: requestContext,
          response,
          data,
        };

        // Run afterResponse middlewares
        for (const middleware of this.afterResponse) {
          await middleware(responseContext);
        }

        // Determine if status is in success or error map
        const status = response.status as number;

        // Check if status is in success map (200-299)
        if (status >= 200 && status < 300) {
          return {
            ok: true,
            status: status as keyof SuccessMap,
            data: data as SuccessMap[keyof SuccessMap],
          } as ApiResult<SuccessMap, ErrorMap>;
        } else {
          // Status is in error map
          return {
            ok: false,
            status: status as keyof ErrorMap,
            error: data as ErrorMap[keyof ErrorMap],
          } as ApiResult<SuccessMap, ErrorMap>;
        }
      } catch (error: any) {
        lastError = error;

        // Check if we should retry
        const shouldRetry = 
          attempt < this.retries &&
          (error.name === "AbortError" ||
           error.message?.includes("network") ||
           error.message?.includes("fetch"));

        if (!shouldRetry) {
          // Run error middlewares
          for (const middleware of this.onError) {
            await middleware(error, requestContext);
          }
          throw error;
        }

        // Wait before retry
        await new Promise((resolve) => setTimeout(resolve, this.retryDelay * (attempt + 1)));
      }
    }

    // All retries exhausted
    for (const middleware of this.onError) {
      await middleware(lastError, requestContext);
    }
    throw lastError;
  }

  async get<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
    path: string,
    opts: RequestOptions = {}
  ): Promise<ApiResult<SuccessMap, ErrorMap>> {
    return this.request<SuccessMap, ErrorMap>("GET", path, opts);
  }

  async post<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
    path: string,
    opts: RequestOptions = {}
  ): Promise<ApiResult<SuccessMap, ErrorMap>> {
    return this.request<SuccessMap, ErrorMap>("POST", path, opts);
  }

  async put<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
    path: string,
    opts: RequestOptions = {}
  ): Promise<ApiResult<SuccessMap, ErrorMap>> {
    return this.request<SuccessMap, ErrorMap>("PUT", path, opts);
  }

  async patch<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
    path: string,
    opts: RequestOptions = {}
  ): Promise<ApiResult<SuccessMap, ErrorMap>> {
    return this.request<SuccessMap, ErrorMap>("PATCH", path, opts);
  }

  async delete<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
    path: string,
    opts: RequestOptions = {}
  ): Promise<ApiResult<SuccessMap, ErrorMap>> {
    return this.request<SuccessMap, ErrorMap>("DELETE", path, opts);
  }
}

/**
 * Default client instance configured from .vika.json.
 * You can use this directly or configure it with middleware.
 * 
 * @example
 * ```typescript
 * import { vikaClient } from "./runtime";
 * 
 * // Add auth middleware
 * vikaClient.useBeforeRequest(async (ctx) => {
 *   ctx.headers["Authorization"] = `Bearer ${getToken()}`;
 * });
 * 
 * // Use in generated API functions
 * const result = await getUsers();
 * if (result.ok) {
 *   console.log(result.data);
 * } else {
 *   console.error(result.error);
 * }
 * ```
 */
export const vikaClient = new VikaClient({
{% if baseUrl %}  baseUrl: "{{ baseUrl }}",
{% endif %}{% if timeout %}  timeout: {{ timeout }},
{% endif %}{% if retries %}  retries: {{ retries }},
{% endif %}{% if retryDelay %}  retryDelay: {{ retryDelay }},
{% endif %}{% if headers %}  headers: {{ headers }},
{% endif %}{% if auth %}  auth: "{{ auth }}",
{% endif %}});

/**
 * Type guard to check if ApiResult is a success response.
 * 
 * @example
 * ```typescript
 * const result = await getUsers();
 * if (isSuccess(result)) {
 *   // TypeScript knows result.data exists
 *   console.log(result.data);
 * }
 * ```
 */
export function isSuccess<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
  result: ApiResult<SuccessMap, ErrorMap>
): result is { ok: true; status: keyof SuccessMap; data: SuccessMap[keyof SuccessMap] } {
  return result.ok === true;
}

/**
 * Type guard to check if ApiResult is an error response.
 * 
 * @example
 * ```typescript
 * const result = await getUsers();
 * if (isError(result)) {
 *   // TypeScript knows result.error exists
 *   console.error(result.error);
 * }
 * ```
 */
export function isError<SuccessMap extends Record<number, any>, ErrorMap extends Record<number, any>>(
  result: ApiResult<SuccessMap, ErrorMap>
): result is { ok: false; status: keyof ErrorMap; error: ErrorMap[keyof ErrorMap] } {
  return result.ok === false;
}

/**
 * Helper middleware factory for Bearer token authentication.
 * 
 * @example
 * ```typescript
 * import { vikaClient, bearerTokenMiddleware } from "./runtime";
 * 
 * vikaClient.useBeforeRequest(
 *   bearerTokenMiddleware(() => localStorage.getItem("token") || "")
 * );
 * ```
 */
export function bearerTokenMiddleware(getToken: () => string | Promise<string>): BeforeRequestMiddleware {
  return async (ctx: RequestContext) => {
    const token = await getToken();
    if (token) {
      ctx.headers["Authorization"] = `Bearer ${token}`;
    }
  };
}

